// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

interface IERC20 {
    function balanceOf(address owner) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transfer(address to, uint256 amount) external returns (bool);
}

interface IRouter {
    function swapExactTokensForTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);
}

contract SimpleTradingAgent {
    address public owner;
    IRouter public router;

    event Bought(address tokenIn, address tokenOut, uint256 amountIn, uint256 amountOut);
    event Sold(address tokenIn, address tokenOut, uint256 amountIn, uint256 amountOut);

    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    constructor(address _router) {
        owner = msg.sender;
        router = IRouter(_router);
    }

    // Approve tokens to router
    function approveToken(address token, uint256 amount) external onlyOwner {
        IERC20(token).approve(address(router), amount);
    }

    // Buy token via router
    function buyToken(
        address tokenIn,
        address tokenOut,
        uint256 amountIn,
        uint256 amountOutMin,
        uint256 deadline
    ) external onlyOwner {
        address ;
        path[0] = tokenIn;
        path[1] = tokenOut;

        IERC20(tokenIn).transfer(address(this), amountIn);
        IERC20(tokenIn).approve(address(router), amountIn);

        uint256[] memory amounts = router.swapExactTokensForTokens(
            amountIn,
            amountOutMin,
            path,
            address(this),
            deadline
        );

        emit Bought(tokenIn, tokenOut, amountIn, amounts[1]);
    }

    // Sell token via router
    function sellToken(
        address tokenIn,
        address tokenOut,
        uint256 amountIn,
        uint256 amountOutMin,
        uint256 deadline
    ) external onlyOwner {
        address ;
        path[0] = tokenIn;
        path[1] = tokenOut;

        IERC20(tokenIn).approve(address(router), amountIn);

        uint256[] memory amounts = router.swapExactTokensForTokens(
            amountIn,
            amountOutMin,
            path,
            address(this),
            deadline
        );

        emit Sold(tokenIn, tokenOut, amountIn, amounts[1]);
    }

    // Withdraw tokens back to owner
    function withdrawToken(address token, uint256 amount) external onlyOwner {
        IERC20(token).transfer(owner, amount);
    }

    // Withdraw native ETH/BNB/MATIC
    function withdrawNative(uint256 amount) external onlyOwner {
        payable(owner).transfer(amount);
    }

    // Receive native tokens
    receive() external payable {}
}
